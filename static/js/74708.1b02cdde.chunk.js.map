{"version":3,"file":"static/js/74708.1b02cdde.chunk.js","mappings":"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","sources":["../node_modules/prismjs/components/prism-graphql.js"],"sourcesContent":["Prism.languages.graphql = {\n\t'comment': /#.*/,\n\t'description': {\n\t\tpattern: /(?:\"\"\"(?:[^\"]|(?!\"\"\")\")*\"\"\"|\"(?:\\\\.|[^\\\\\"\\r\\n])*\")(?=\\s*[a-z_])/i,\n\t\tgreedy: true,\n\t\talias: 'string',\n\t\tinside: {\n\t\t\t'language-markdown': {\n\t\t\t\tpattern: /(^\"(?:\"\")?)(?!\\1)[\\s\\S]+(?=\\1$)/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: Prism.languages.markdown\n\t\t\t}\n\t\t}\n\t},\n\t'string': {\n\t\tpattern: /\"\"\"(?:[^\"]|(?!\"\"\")\")*\"\"\"|\"(?:\\\\.|[^\\\\\"\\r\\n])*\"/,\n\t\tgreedy: true\n\t},\n\t'number': /(?:\\B-|\\b)\\d+(?:\\.\\d+)?(?:e[+-]?\\d+)?\\b/i,\n\t'boolean': /\\b(?:true|false)\\b/,\n\t'variable': /\\$[a-z_]\\w*/i,\n\t'directive': {\n\t\tpattern: /@[a-z_]\\w*/i,\n\t\talias: 'function'\n\t},\n\t'attr-name': {\n\t\tpattern: /[a-z_]\\w*(?=\\s*(?:\\((?:[^()\"]|\"(?:\\\\.|[^\\\\\"\\r\\n])*\")*\\))?:)/i,\n\t\tgreedy: true\n\t},\n\t'atom-input': {\n\t\tpattern: /[A-Z]\\w*Input(?=!?.*$)/m,\n\t\talias: 'class-name'\n\t},\n\t'scalar': /\\b(?:Boolean|Float|ID|Int|String)\\b/,\n\t'constant': /\\b[A-Z][A-Z_\\d]*\\b/,\n\t'class-name': {\n\t\tpattern: /(\\b(?:enum|implements|interface|on|scalar|type|union)\\s+|&\\s*|:\\s*|\\[)[A-Z_]\\w*/,\n\t\tlookbehind: true\n\t},\n\t'fragment': {\n\t\tpattern: /(\\bfragment\\s+|\\.{3}\\s*(?!on\\b))[a-zA-Z_]\\w*/,\n\t\tlookbehind: true,\n\t\talias: 'function'\n\t},\n\t'definition-mutation': {\n\t\tpattern: /(\\bmutation\\s+)[a-zA-Z_]\\w*/,\n\t\tlookbehind: true,\n\t\talias: 'function'\n\t},\n\t'definition-query': {\n\t\tpattern: /(\\bquery\\s+)[a-zA-Z_]\\w*/,\n\t\tlookbehind: true,\n\t\talias: 'function'\n\t},\n\t'keyword': /\\b(?:directive|enum|extend|fragment|implements|input|interface|mutation|on|query|repeatable|scalar|schema|subscription|type|union)\\b/,\n\t'operator': /[!=|&]|\\.{3}/,\n\t'property-query': /\\w+(?=\\s*\\()/,\n\t'object': /\\w+(?=\\s*\\{)/,\n\t'punctuation': /[!(){}\\[\\]:=,]/,\n\t'property': /\\w+/\n};\n\nPrism.hooks.add('after-tokenize', function afterTokenizeGraphql(env) {\n\tif (env.language !== 'graphql') {\n\t\treturn;\n\t}\n\n\t/**\n\t * get the graphql token stream that we want to customize\n\t *\n\t * @typedef {InstanceType<import(\"./prism-core\")[\"Token\"]>} Token\n\t * @type {Token[]}\n\t */\n\tvar validTokens = env.tokens.filter(function (token) {\n\t\treturn typeof token !== 'string' && token.type !== 'comment' && token.type !== 'scalar';\n\t});\n\n\tvar currentIndex = 0;\n\n\t/**\n\t * Returns whether the token relative to the current index has the given type.\n\t *\n\t * @param {number} offset\n\t * @returns {Token | undefined}\n\t */\n\tfunction getToken(offset) {\n\t\treturn validTokens[currentIndex + offset];\n\t}\n\n\t/**\n\t * Returns whether the token relative to the current index has the given type.\n\t *\n\t * @param {readonly string[]} types\n\t * @param {number} [offset=0]\n\t * @returns {boolean}\n\t */\n\tfunction isTokenType(types, offset) {\n\t\toffset = offset || 0;\n\t\tfor (var i = 0; i < types.length; i++) {\n\t\t\tvar token = getToken(i + offset);\n\t\t\tif (!token || token.type !== types[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Returns the index of the closing bracket to an opening bracket.\n\t *\n\t * It is assumed that `token[currentIndex - 1]` is an opening bracket.\n\t *\n\t * If no closing bracket could be found, `-1` will be returned.\n\t *\n\t * @param {RegExp} open\n\t * @param {RegExp} close\n\t * @returns {number}\n\t */\n\tfunction findClosingBracket(open, close) {\n\t\tvar stackHeight = 1;\n\n\t\tfor (var i = currentIndex; i < validTokens.length; i++) {\n\t\t\tvar token = validTokens[i];\n\t\t\tvar content = token.content;\n\n\t\t\tif (token.type === 'punctuation' && typeof content === 'string') {\n\t\t\t\tif (open.test(content)) {\n\t\t\t\t\tstackHeight++;\n\t\t\t\t} else if (close.test(content)) {\n\t\t\t\t\tstackHeight--;\n\n\t\t\t\t\tif (stackHeight === 0) {\n\t\t\t\t\t\treturn i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\t/**\n\t * Adds an alias to the given token.\n\t *\n\t * @param {Token} token\n\t * @param {string} alias\n\t * @returns {void}\n\t */\n\tfunction addAlias(token, alias) {\n\t\tvar aliases = token.alias;\n\t\tif (!aliases) {\n\t\t\ttoken.alias = aliases = [];\n\t\t} else if (!Array.isArray(aliases)) {\n\t\t\ttoken.alias = aliases = [aliases];\n\t\t}\n\t\taliases.push(alias);\n\t}\n\n\tfor (; currentIndex < validTokens.length;) {\n\t\tvar startToken = validTokens[currentIndex++];\n\n\t\t// add special aliases for mutation tokens\n\t\tif (startToken.type === 'keyword' && startToken.content === 'mutation') {\n\t\t\t// any array of the names of all input variables (if any)\n\t\t\tvar inputVariables = [];\n\n\t\t\tif (isTokenType(['definition-mutation', 'punctuation']) && getToken(1).content === '(') {\n\t\t\t\t// definition\n\n\t\t\t\tcurrentIndex += 2; // skip 'definition-mutation' and 'punctuation'\n\n\t\t\t\tvar definitionEnd = findClosingBracket(/^\\($/, /^\\)$/);\n\t\t\t\tif (definitionEnd === -1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// find all input variables\n\t\t\t\tfor (; currentIndex < definitionEnd; currentIndex++) {\n\t\t\t\t\tvar t = getToken(0);\n\t\t\t\t\tif (t.type === 'variable') {\n\t\t\t\t\t\taddAlias(t, 'variable-input');\n\t\t\t\t\t\tinputVariables.push(t.content);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcurrentIndex = definitionEnd + 1;\n\t\t\t}\n\n\t\t\tif (isTokenType(['punctuation', 'property-query']) && getToken(0).content === '{') {\n\t\t\t\tcurrentIndex++; // skip opening bracket\n\n\t\t\t\taddAlias(getToken(0), 'property-mutation');\n\n\t\t\t\tif (inputVariables.length > 0) {\n\t\t\t\t\tvar mutationEnd = findClosingBracket(/^\\{$/, /^\\}$/);\n\t\t\t\t\tif (mutationEnd === -1) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// give references to input variables a special alias\n\t\t\t\t\tfor (var i = currentIndex; i < mutationEnd; i++) {\n\t\t\t\t\t\tvar varToken = validTokens[i];\n\t\t\t\t\t\tif (varToken.type === 'variable' && inputVariables.indexOf(varToken.content) >= 0) {\n\t\t\t\t\t\t\taddAlias(varToken, 'variable-input');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n});\n"],"names":["Prism","languages","graphql","pattern","greedy","alias","inside","lookbehind","markdown","hooks","add","env","language","validTokens","tokens","filter","token","type","currentIndex","length","startToken","content","inputVariables","isTokenType","getToken","definitionEnd","findClosingBracket","t","addAlias","push","mutationEnd","i","varToken","indexOf","offset","types","open","close","stackHeight","test","aliases","Array","isArray"],"sourceRoot":""}